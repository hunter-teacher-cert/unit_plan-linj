/* autogenerated by Processing revision 1286 on 2022-12-08 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class TicTacToe extends PApplet {

//GAME VARIABLES
Grid grid = new Grid(3);
PImage bg;
PImage x_letter;
PImage o_letter;
String titleText = "Triple J TicTacToe";
String turnText = "Who goes first?";
String winner = "";
boolean isXTurn = true;

int numHorses = 5;
Sprite[] horses = new Sprite[numHorses];


//Required Processing method that gets run once
 public void setup() {
  /* size commented out by preprocessor */;  //match screen size to bg image size
  surface.setTitle("Triple J Game");

  //Load images used
  bg = loadImage("images/grid.jpg");
  x_letter = loadImage("images/x_wood.png");
  x_letter.resize(100,100);
  o_letter = loadImage("images/o_wood.png");
  o_letter.resize(100,100);
 
  //construct 5 horses for end animation
  for(int i=0; i<numHorses; i++){
      horses[i] = new Sprite(0, i*75, Math.random() + 0.1f, "sprites/horse_run.png", "sprites/horse_run.json");
  }

  print("TripleJ TicTacToe Game started...");

  //fullScreen();   //only use if not using a specfic bg image
}

//Required Processing method that automatically loops
//(Anything drawn on the screen should be called from here)
 public void draw() {

  updateTitleBar();
  
  updateScreen();

  if(isGameOver()){
    endGame();
  }
  
}


//Known Processing method that automatically will run when a mouse click triggers it
 public void mouseClicked(){
  
  //check if click was successful
  boolean goodClick = false;

  //if clicked, change the mark in that square
  GridLocation lastClickedLoc = grid.getGridLocation();  
  System.out.println(lastClickedLoc);
  if(isXTurn){
    goodClick = grid.setMark("X", lastClickedLoc);
  } else {
    goodClick = grid.setMark("O", lastClickedLoc);
  }

  //alternate the turn if a good click
  if(goodClick){
    isXTurn = !isXTurn;
  }
}




//------------------ CUSTOM  METHODS --------------------//

//method to update the Title Bar of the Game
public void updateTitleBar(){

  if(!isGameOver()) {
    //set the title each loop
    surface.setTitle(titleText + "          " + turnText);

    //determine how to prompt the next move
    if(isXTurn){
      turnText = "Click for X";
    } else {
      turnText = "Click for O";
    }
  }

}

//method to update what is drawn on the screen each frame
public void updateScreen(){

  //update the background
  background(bg);
  
  //update each grid location
  for(int r = 0; r<grid.getSize(); r++){
    for(int c= 0; c<grid.getSize(); c++){
      GridLocation loc = new GridLocation(r,c);
      
      //Paint X's and O's in the approprate grid locations
      if(grid.getSquare(loc).getMark().equals("X") ){
        image(x_letter,grid.getX(loc) - x_letter.width/2,grid.getY(loc) - x_letter.height/2);  
      } else if (grid.getSquare(loc).getMark().equals("O")){
        image(o_letter,grid.getX(loc) - o_letter.width/2,grid.getY(loc) - o_letter.height/2);
      }
      
    }
  }
}

//method to check if there are 3 marks in a row
public boolean isThreeInARow(){
  
  //check Row wins
  for(int r=0; r<grid.getSize(); r++){
    String markC0 = grid.getSquare(r,0).getMark();
    if(markC0 != " " 
       && grid.getSquare(r,1).getMark().equals(markC0) 
       && grid.getSquare(r,2).getMark().equals(markC0)
    ){
      System.out.println(markC0 + " wins (Three in a Row!)");
      winner = markC0;
      return true;
    }
  }

  //check row wins
  for(int c=0; c<grid.getSize(); c++){
    String markR0 = grid.getSquare(0,c).getMark();
    if(markR0 != " "
       && grid.getSquare(1,c).getMark().equals(markR0) 
       && grid.getSquare(2,c).getMark().equals(markR0)
    ){
      System.out.println(markR0 + " wins (Three in a Row)");
      winner = markR0;
      return true;
    }
  }

  //check diagonal wins
  String mark11 = grid.getSquare(1,1).getMark();
  if(mark11 != " "
     && ((grid.getSquare(0,0).getMark().equals(mark11)
     && grid.getSquare(2,2).getMark().equals(mark11))
     || (grid.getSquare(2,0).getMark().equals(mark11)
     && grid.getSquare(0,2).getMark().equals(mark11)))
  ){
    System.out.println(mark11 + " wins! (Three in a diagonal)");
    winner = mark11; 
    return true;
  }

  return false;
}

//method to indicate when the main game is over
public boolean isGameOver(){
  return isThreeInARow();
}

//method to describe what happens after the game is over
public void endGame(){
    System.out.println("THREE IN A ROW! ");
    surface.setTitle("Three in a Row!  " + winner + " wins! Game over! ");

    //Show an animation of 5 running horses
    for(Sprite horse: horses){
      horse.show();
      horse.animate();
    }
}
public class Grid{
  
  private int size;
  private Square[][] board;
  
  public Grid(){
     this(3);
  }

  public Grid(int size){
    this.size = size;
    board = new Square[size][size];
    
    for(int r=0; r<size; r++){
      for(int c=0; c<size; c++){
         board[r][c] = new Square();
      }
    }
  }
  
  public boolean setMark(String mark, GridLocation loc){
   
    boolean isGoodClick;

    int row = loc.getR();
    int col = loc.getC();
    
    isGoodClick = board[row][col].setMark(mark);
    printGrid();

    return isGoodClick;
    
  } 
  

  public void printGrid(){
   
    for(int r = 0; r<size; r++){
      for(int c = 0; c<size; c++){
         System.out.print(board[r][c]);
      }
      System.out.println();
    } 
  }
  
  public GridLocation getGridLocation(){
   
    //map the mouse coordinates to the grid GridLocation
    int sizeOfOneSquare = pixelHeight/this.size;
    //System.out.println(displayHeight + " " + pixelHeight + " " + sizeOfOneSquare);
    
    int row = mouseY/sizeOfOneSquare;
    int col = mouseX/sizeOfOneSquare;

    return new GridLocation(row, col);
  } 

  public int getX(GridLocation loc){
    
    int sizeOfOneSquare = pixelHeight/this.size;
 
    //calculate the center of the grid GridLocation
    int pixelX = (sizeOfOneSquare/2) + (sizeOfOneSquare * loc.getC()); 
    
    return pixelX;
  } 
  
  public int getY(GridLocation loc){
    
    int sizeOfOneSquare = pixelHeight/this.size;
 
    //calculate the center of the grid GridLocation
    int pixelY = (sizeOfOneSquare/2) + (sizeOfOneSquare * loc.getR()); 
    
    return pixelY;
  } 
  
  
  public int getSize(){
    return size;
  }
  
  public Square getSquare(GridLocation loc){
    return board[loc.getR()][loc.getC()];
  }
  public Square getSquare(int r, int c){
    return board[r][c];
  }
  
  public boolean isGameOver(){
    return false;
  }
  
}
public class GridLocation{
 
  int row;
  int col;
  
  public GridLocation(int row, int col){
    this.row = row;
    this.col = col;
  }
  
  public int getR(){
    return row;
  }
  
  public int getC(){
    return col;
  }
  
  public String toString(){
    return row + "," + col;
  }
  
}
// Revised from Daniel Shiffman's p5js Animated Sprite tutorial
// Expects .json spritesheet from TexturePack software

// https://editor.p5js.org/codingtrain/sketches/vhnFx1mml
// http://youtube.com/thecodingtrain
// https://thecodingtrain.com/CodingChallenges/111-animated-sprite.html

// Horse Spritesheet from
// https://opengameart.org/content/2d-platformer-art-assets-from-horse-of-spring

// Animated Sprite
// https://youtu.be/3noMeuufLZY

public class Sprite {
  
    private int x;
    private int y;
    private ArrayList<PImage> animation;
    private int w;
    private int len;
    private double speed;
    private int index;
    private boolean isAnimated;

    JSONObject spriteData;
    PImage spriteSheet;


  // Main Constructor
  public Sprite(int x, int y, double speed, String png, String json, boolean isAnimated) {
    this.x = x;
    this.y = y;
    this.animation = new ArrayList<PImage>();
    this.isAnimated = isAnimated;

    if(!isAnimated){
      PImage pi = loadImage(png);
      animation.add(pi);
    } else {
    
      spriteData = loadJSONObject(json);
      spriteSheet = loadImage(png);
      JSONArray frames = spriteData.getJSONArray("frames");
      
      for(int i=0; i<frames.size(); i++){

          JSONObject frame = frames.getJSONObject(i);
          //System.out.println(i + ": " + frame + "\n");
          JSONObject fr = frame.getJSONObject("frame");
          //System.out.println("ss: " + fr + "\n");

          int sX = fr.getInt("x");
          int sY = fr.getInt("y");
          int sW = fr.getInt("w");
          int sH = fr.getInt("h");
          //System.out.println(i + ":\t sX:" + sX + ":\t sY:" + sY + ":\t sW:" + sW + ":\t sH:" + sH);
          PImage img = spriteSheet.get(sX, sY, sW, sH);
          animation.add(img);

          this.w = this.animation.get(0).width;
          this.len = this.animation.size();
          this.speed = speed;
          this.index = 0;
      }
    }
  }

  // Constructor for Non-Animated image
  public Sprite(int x, int y,  String png) {
    this(x, y, 0.0f, png, "", false);
    //System.out.println("Non-animated sprite created");
  }

  // Constructor for Animated Image with Spritesheet (Must use the TexturePacker to make the JSON)
  // https://www.codeandweb.com/texturepacker
  public Sprite(int x, int y, double speed, String png, String json) {
    this(x, y, speed, png, json, true);
    //System.out.println("Animated sprite created");
  }


  //animated method to display the Sprite image on the screen
  public void show() {
    if(!isAnimated){
      image(animation.get(0), this.x, this.y);
    } else{
      int index = (int) Math.floor(Math.abs(this.index)) % this.len;
      image(animation.get(Math.abs(this.index) % this.animation.size()), this.x, this.y);
    }
  }

  //animated method that makes the Sprite move to the right
  public void animate() {

    if(isAnimated){
      //adjust speed & frames
      this.index += this.speed * 10;
      this.x += this.speed * 15;
    
      //wraparound sprite if goes off the right or left
      if (this.x > width) {
        this.x = -this.w;
      } else if (this.x < -width){
        this.x = width;
      }
    }
  }
  

}
public class Square{
  
  private PImage pi;
  private String mark;
  final private static String noMark = " ";
  final private static String xMark = "X";
  final private static String oMark = "O";
  
  public Square(){
    this(noMark);
  }

  public Square(String mark){
    this.mark = mark;

  }
  
  //accessor
  public String getMark(){
    return mark;
  }
  
  //mutator
  public boolean setMark(String mark){
    if(this.mark.equals(noMark)){
      this.mark = mark;
      System.out.println("Successfully changed mark");
      return true;
    } else {
      System.out.println("That square is already taken!");
      return false;
    }
  }
  
  public void setX(){
    if(mark.equals(noMark)){
      mark = xMark;
    } else {
      System.out.println("Already taken!");
    }
  }
  public void setO(){
    mark = oMark;
  }
  
  public String toString(){
    return mark;
  }

  public PImage getImage(){
    return pi;
  }
  
}


  public void settings() { size(440, 440); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "TicTacToe" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
